using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using System.Net;
using System.Text;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using QRCoder;
using System.Drawing;
using System.Drawing.Imaging;
using Einsatzueberwachung.Models;

namespace Einsatzueberwachung.Services
{
    public class MobileIntegrationService
    {
        private HttpListener? _httpListener;
        private readonly int _port = 8080;
        private string _baseUrl;
        private bool _isRunning = false;
        private string _localIPAddress;
        
        // Delegate to get current teams from MainWindow
        public Func<List<Team>>? GetCurrentTeams { get; set; }
        public Func<EinsatzData?>? GetEinsatzData { get; set; }
        
        public event Action<string>? StatusChanged;
        
        public string QRCodeUrl => $"http://{_localIPAddress}:{_port}/mobile";
        public bool IsRunning => _isRunning;
        public string LocalIPAddress => _localIPAddress;

        public MobileIntegrationService()
        {
            _localIPAddress = GetLocalIPAddress();
            _baseUrl = $"http://{_localIPAddress}:{_port}";
            
            // F√ºhre Netzwerk- und Firewall-Checks durch
            CheckFirewallAndNetwork();
        }

        private string GetLocalIPAddress()
        {
            try
            {
                StatusChanged?.Invoke("üîç Suche nach lokaler IP-Adresse...");
                
                // Hole alle Netzwerk-Interfaces
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up && 
                               ni.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                    .ToList();
                
                StatusChanged?.Invoke($"üì° Gefundene Netzwerk-Interfaces: {networkInterfaces.Count}");
                
                foreach (var ni in networkInterfaces)
                {
                    var ipProperties = ni.GetIPProperties();
                    var ipAddresses = ipProperties.UnicastAddresses
                        .Where(addr => addr.Address.AddressFamily == AddressFamily.InterNetwork && 
                                     !IPAddress.IsLoopback(addr.Address))
                        .Select(addr => addr.Address)
                        .ToList();
                    
                    foreach (var ip in ipAddresses)
                    {
                        var ipString = ip.ToString();
                        StatusChanged?.Invoke($"üîç Pr√ºfe IP: {ipString} ({ni.Name})");
                        
                        // Bevorzuge private Netzwerk-Adressen
                        if (ipString.StartsWith("192.168.") || 
                            ipString.StartsWith("10.") ||
                            (ipString.StartsWith("172.") && 
                             int.TryParse(ipString.Split('.')[1], out int second) && 
                             second >= 16 && second <= 31))
                        {
                            StatusChanged?.Invoke($"‚úÖ Lokale IP gefunden: {ipString}");
                            return ipString;
                        }
                    }
                }
                
                // Fallback: Verwende DNS-Lookup
                StatusChanged?.Invoke("üîÑ Fallback: DNS-Lookup...");
                var host = Dns.GetHostEntry(Dns.GetHostName());
                var fallbackIp = host.AddressList
                    .FirstOrDefault(ip => ip.AddressFamily == AddressFamily.InterNetwork && 
                                         !IPAddress.IsLoopback(ip));
                
                if (fallbackIp != null)
                {
                    StatusChanged?.Invoke($"‚úÖ DNS-IP gefunden: {fallbackIp}");
                    return fallbackIp.ToString();
                }
                
                StatusChanged?.Invoke("‚ö†Ô∏è Keine Netzwerk-IP gefunden, verwende localhost");
                return "localhost";
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå IP-Adress-Fehler: {ex.Message}");
                return "localhost";
            }
        }

        public byte[] GenerateQRCode()
        {
            try
            {
                var qrGenerator = new QRCodeGenerator();
                var qrCodeData = qrGenerator.CreateQrCode(QRCodeUrl, QRCodeGenerator.ECCLevel.Q);
                var qrCode = new QRCode(qrCodeData);
                
                using var qrCodeImage = qrCode.GetGraphic(20, Color.Black, Color.White, true);
                using var stream = new MemoryStream();
                qrCodeImage.Save(stream, ImageFormat.Png);
                return stream.ToArray();
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"QR-Code Fehler: {ex.Message}");
                return Array.Empty<byte>();
            }
        }

        public async Task<bool> StartServerAsync()
        {
            try
            {
                StatusChanged?.Invoke("üöÄ Starte Mobile Server...");
                StatusChanged?.Invoke($"üîç System-Check: Windows {Environment.OSVersion.VersionString}");
                StatusChanged?.Invoke($"üíª .NET Version: {Environment.Version}");
                
                // Phase 1: Kritische Checks
                if (!await PerformCriticalChecks())
                {
                    return false;
                }
                
                bool isAdmin = IsRunningAsAdministrator();
                StatusChanged?.Invoke($"üîê Administrator-Rechte: {(isAdmin ? "‚úÖ Verf√ºgbar" : "‚ùå Nicht verf√ºgbar")}");
                
                // Phase 2: Netzwerk-Vorbereitung
                if (isAdmin)
                {
                    StatusChanged?.Invoke("üîß F√ºhre automatische Admin-Konfiguration durch...");
                    await ConfigureNetworkAccess();
                }
                else
                {
                    StatusChanged?.Invoke("üîÑ Verwende Nicht-Admin-Strategien f√ºr Netzwerk-Zugriff...");
                    await ConfigureNetworkAccessWithoutAdmin();
                }
                
                // Phase 3: HttpListener Setup
                return await SetupHttpListener();
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Schwerwiegender Server-Start-Fehler: {ex.GetType().Name}");
                StatusChanged?.Invoke($"‚ùå Fehlermeldung: {ex.Message}");
                if (!string.IsNullOrEmpty(ex.StackTrace))
                {
                    var stackTrace = ex.StackTrace.Length > 200 ? ex.StackTrace.Substring(0, 200) + "..." : ex.StackTrace;
                    StatusChanged?.Invoke($"‚ùå Stack Trace: {stackTrace}");
                }
                
                // Versuche Fallback-Methoden
                StatusChanged?.Invoke("üîÑ Versuche Notfall-Server-Methoden...");
                return await TryEmergencyServerStart();
            }
        }
        
        private async Task<bool> PerformCriticalChecks()
        {
            try
            {
                StatusChanged?.Invoke("üîç F√ºhre kritische System-Checks durch...");
                
                // 1. HttpListener Support
                if (!HttpListener.IsSupported)
                {
                    StatusChanged?.Invoke("‚ùå KRITISCH: HttpListener wird nicht unterst√ºtzt");
                    StatusChanged?.Invoke("üí° L√∂sung: .NET Runtime neu installieren oder System-Update");
                    return false;
                }
                StatusChanged?.Invoke("‚úÖ HttpListener wird unterst√ºtzt");
                
                // 2. Netzwerk-Interfaces
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up)
                    .ToList();
                    
                if (networkInterfaces.Count == 0)
                {
                    StatusChanged?.Invoke("‚ùå WARNUNG: Keine aktiven Netzwerk-Interfaces gefunden");
                    StatusChanged?.Invoke("üí° Netzwerk-Verbindung pr√ºfen");
                }
                else
                {
                    StatusChanged?.Invoke($"‚úÖ {networkInterfaces.Count} aktive Netzwerk-Interfaces gefunden");
                }
                
                // 3. Port-Verf√ºgbarkeit pr√ºfen
                await CheckAndResolvePortConflicts();
                
                StatusChanged?.Invoke("‚úÖ Kritische Checks abgeschlossen");
                return true;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Fehler bei kritischen Checks: {ex.Message}");
                return true; // Weitermachen trotz Fehlern
            }
        }
        
        private async Task CheckAndResolvePortConflicts()
        {
            try
            {
                var tcpConnections = System.Net.NetworkInformation.IPGlobalProperties
                    .GetIPGlobalProperties()
                    .GetActiveTcpListeners();
                
                var portInUse = tcpConnections.Any(endpoint => endpoint.Port == _port);
                
                if (portInUse)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Port {_port} wird bereits verwendet");
                    
                    // Versuche herauszufinden welcher Prozess den Port verwendet
                    try
                    {
                        var processInfo = new System.Diagnostics.ProcessStartInfo
                        {
                            FileName = "netstat",
                            Arguments = $"-ano | findstr :{_port}",
                            UseShellExecute = false,
                            RedirectStandardOutput = true,
                            CreateNoWindow = true
                        };
                        
                        using var process = System.Diagnostics.Process.Start(processInfo);
                        if (process != null)
                        {
                            await process.WaitForExitAsync();
                            var output = await process.StandardOutput.ReadToEndAsync();
                            
                            if (!string.IsNullOrEmpty(output))
                            {
                                StatusChanged?.Invoke($"üîç Port {_port} Details: {output.Trim()}");
                                
                                // Versuche den Prozess zu identifizieren
                                var lines = output.Split('\n');
                                foreach (var line in lines)
                                {
                                    if (line.Contains($":{_port}"))
                                    {
                                        var parts = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                                        if (parts.Length > 0 && int.TryParse(parts.Last(), out int pid))
                                        {
                                            try
                                            {
                                                var proc = System.Diagnostics.Process.GetProcessById(pid);
                                                StatusChanged?.Invoke($"üìã Port {_port} verwendet von: {proc.ProcessName} (PID: {pid})");
                                                
                                                // Wenn es unser eigener Prozess ist, versuche ihn zu beenden
                                                if (proc.ProcessName.Contains("Einsatzueberwachung") || 
                                                    proc.ProcessName.Contains("Einsatz√ºberwachung"))
                                                {
                                                    StatusChanged?.Invoke("üîÑ Beende vorherige Instanz...");
                                                    proc.Kill();
                                                    await Task.Delay(2000); // Warte 2 Sekunden
                                                    StatusChanged?.Invoke("‚úÖ Vorherige Instanz beendet");
                                                }
                                            }
                                            catch
                                            {
                                                StatusChanged?.Invoke($"‚ö†Ô∏è Prozess PID {pid} konnte nicht identifiziert werden");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        StatusChanged?.Invoke($"‚ö†Ô∏è Port-Analyse fehlgeschlagen: {ex.Message}");
                    }
                    
                    StatusChanged?.Invoke("üí° Alternative Ports werden automatisch getestet");
                }
                else
                {
                    StatusChanged?.Invoke($"‚úÖ Port {_port} ist verf√ºgbar");
                }
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Port-Check Fehler: {ex.Message}");
            }
        }
        
        private async Task<bool> SetupHttpListener()
        {
            const int maxRetries = 3;
            int currentRetry = 0;
            
            while (currentRetry < maxRetries)
            {
                try
                {
                    currentRetry++;
                    StatusChanged?.Invoke($"üîß HttpListener Setup (Versuch {currentRetry}/{maxRetries})...");
                    
                    // Alten Listener schlie√üen
                    _httpListener?.Close();
                    _httpListener = new HttpListener();
                    
                    // Prefixes konfigurieren
                    bool networkAccessConfigured = await ConfigurePrefixes();
                    StatusChanged?.Invoke($"üìã Konfigurierte Prefixes: {_httpListener.Prefixes.Count}");
                    
                    if (_httpListener.Prefixes.Count == 0)
                    {
                        StatusChanged?.Invoke("‚ùå Keine g√ºltigen Prefixes konfiguriert");
                        if (currentRetry < maxRetries)
                        {
                            StatusChanged?.Invoke($"üîÑ Wiederhole in 2 Sekunden... (Versuch {currentRetry + 1}/{maxRetries})");
                            await Task.Delay(2000);
                            continue;
                        }
                        return false;
                    }
                    
                    // HttpListener starten
                    StatusChanged?.Invoke("üöÄ Starte HttpListener...");
                    _httpListener.Start();
                    _isRunning = true;
                    
                    StatusChanged?.Invoke("‚úÖ HttpListener erfolgreich gestartet");
                    
                    // Erfolgreiche Konfiguration melden
                    ReportSuccessfulStart(networkAccessConfigured);
                    
                    // Request Handler starten
                    StatusChanged?.Invoke("üîÑ Starte Request-Handler...");
                    _ = Task.Run(HandleRequestsAsync);
                    
                    // Netzwerk-Tests durchf√ºhren
                    await TestNetworkReachability();
                    
                    StatusChanged?.Invoke("üéâ Mobile Server vollst√§ndig einsatzbereit!");
                    return true;
                }
                catch (HttpListenerException ex)
                {
                    StatusChanged?.Invoke($"üö® HttpListener Fehler (Versuch {currentRetry}): {ex.ErrorCode} - {ex.Message}");
                    
                    switch (ex.ErrorCode)
                    {
                        case 5: // Access Denied
                            StatusChanged?.Invoke("üîë Zugriff verweigert - Admin-Rechte erforderlich");
                            if (currentRetry >= maxRetries)
                            {
                                return await TryAlternativeServerMethods();
                            }
                            break;
                            
                        case 183: // Already exists
                            StatusChanged?.Invoke("‚ö†Ô∏è Port bereits belegt - warte und versuche erneut");
                            await Task.Delay(3000);
                            break;
                            
                        case 87: // Invalid parameter
                            StatusChanged?.Invoke("‚ùå Ung√ºltige Prefix-Konfiguration");
                            return await TryMinimalConfiguration();
                            
                        default:
                            StatusChanged?.Invoke($"‚ùå Unbekannter HttpListener-Fehler: {ex.ErrorCode}");
                            break;
                    }
                    
                    if (currentRetry >= maxRetries)
                    {
                        StatusChanged?.Invoke("üö® Maximale Wiederholungen erreicht - versuche alternative Methoden");
                        return await TryAlternativeServerMethods();
                    }
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"‚ùå Unerwarteter Fehler (Versuch {currentRetry}): {ex.Message}");
                    
                    if (currentRetry >= maxRetries)
                    {
                        return await TryEmergencyServerStart();
                    }
                    
                    await Task.Delay(1000 * currentRetry); // Exponential backoff
                }
            }
            
            return false;
        }
        
        private void ReportSuccessfulStart(bool networkAccessConfigured)
        {
            var isAdmin = IsRunningAsAdministrator();
            
            if (networkAccessConfigured && _localIPAddress != "localhost")
            {
                var accessType = isAdmin ? "VOLLST√ÑNDIGEM Admin" : "ERWEITERTEN";
                StatusChanged?.Invoke($"üåê Mobile Server gestartet mit {accessType} Netzwerk-Zugriff!");
                StatusChanged?.Invoke($"üì± iPhone URL: http://{_localIPAddress}:{_port}/mobile");
                StatusChanged?.Invoke($"üíª Desktop URL: http://localhost:{_port}/mobile");
                StatusChanged?.Invoke($"üîß Debug URL: http://localhost:{_port}/debug");
                StatusChanged?.Invoke($"üåç QR-Code URL: {QRCodeUrl}");
            }
            else
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Mobile Server gestartet (EINGESCHR√ÑNKT - NUR LOCALHOST)");
                StatusChanged?.Invoke($"üíª Desktop URL: http://localhost:{_port}/mobile");
                StatusChanged?.Invoke($"üîß Debug URL: http://localhost:{_port}/debug");
                StatusChanged?.Invoke("");
                StatusChanged?.Invoke("üí° F√úR IPHONE-ZUGRIFF:");
                StatusChanged?.Invoke("   ‚Ä¢ Als Administrator starten (empfohlen)");
                StatusChanged?.Invoke("   ‚Ä¢ 'Netzwerk konfigurieren' verwenden");
                StatusChanged?.Invoke("   ‚Ä¢ 'Ohne Admin-Rechte' f√ºr Alternativen");
                StatusChanged?.Invoke("   ‚Ä¢ Windows Mobile Hotspot aktivieren");
            }
        }
        
        private async Task<bool> TryMinimalConfiguration()
        {
            try
            {
                StatusChanged?.Invoke("üîÑ Versuche minimale Konfiguration...");
                
                _httpListener?.Close();
                _httpListener = new HttpListener();
                
                // Nur localhost hinzuf√ºgen
                _httpListener.Prefixes.Add($"http://localhost:{_port}/");
                _httpListener.Prefixes.Add($"http://127.0.0.1:{_port}/");
                
                _httpListener.Start();
                _isRunning = true;
                
                StatusChanged?.Invoke("‚úÖ Minimaler Server gestartet (nur localhost)");
                StatusChanged?.Invoke($"üíª URL: http://localhost:{_port}/mobile");
                
                _ = Task.Run(HandleRequestsAsync);
                return true;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Minimale Konfiguration fehlgeschlagen: {ex.Message}");
                return false;
            }
        }
        
        private async Task<bool> TryEmergencyServerStart()
        {
            try
            {
                StatusChanged?.Invoke("üö® NOTFALL-SERVER-START...");
                StatusChanged?.Invoke("üîÑ Versuche alle verf√ºgbaren Fallback-Methoden...");
                
                // Versuche alternative Ports
                var emergencyPorts = new[] { 8081, 8082, 8083, 9000, 9001, 3000, 5000, 7000 };
                
                foreach (var port in emergencyPorts)
                {
                    try
                    {
                        StatusChanged?.Invoke($"üîÑ Teste Port {port}...");
                        
                        _httpListener?.Close();
                        _httpListener = new HttpListener();
                        _httpListener.Prefixes.Add($"http://localhost:{port}/");
                        
                        _httpListener.Start();
                        _isRunning = true;
                        
                        StatusChanged?.Invoke($"‚úÖ NOTFALL-SERVER ERFOLGREICH auf Port {port}!");
                        StatusChanged?.Invoke($"üíª Notfall-URL: http://localhost:{port}/mobile");
                        StatusChanged?.Invoke($"üì± F√ºr iPhone: Manuelle Netzwerk-Konfiguration erforderlich");
                        
                        _ = Task.Run(HandleRequestsAsync);
                        return true;
                    }
                    catch (Exception ex)
                    {
                        StatusChanged?.Invoke($"‚ö†Ô∏è Port {port} fehlgeschlagen: {ex.Message}");
                    }
                }
                
                StatusChanged?.Invoke("‚ùå ALLE NOTFALL-METHODEN FEHLGESCHLAGEN");
                StatusChanged?.Invoke("üí° LETZTE L√ñSUNGSVERSUCHE:");
                StatusChanged?.Invoke("   1. Computer neu starten");
                StatusChanged?.Invoke("   2. Als Administrator erneut versuchen");
                StatusChanged?.Invoke("   3. Windows Firewall tempor√§r deaktivieren");
                StatusChanged?.Invoke("   4. Antivirus-Software pr√ºfen");
                
                return false;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"üö® KRITISCHER NOTFALL-FEHLER: {ex.Message}");
                return false;
            }
        }

        private async Task<bool> CheckSystemRequirements()
        {
            try
            {
                StatusChanged?.Invoke("üîç Pr√ºfe System-Anforderungen...");
                
                // 1. .NET Version Check
                var dotnetVersion = Environment.Version;
                StatusChanged?.Invoke($"üîç .NET Runtime: {dotnetVersion}");
                
                // 2. Windows Version Check
                var osVersion = Environment.OSVersion;
                StatusChanged?.Invoke($"üîç Betriebssystem: {osVersion.VersionString}");
                
                if (osVersion.Platform != PlatformID.Win32NT)
                {
                    StatusChanged?.Invoke("‚ùå Nicht-Windows-System erkannt - HttpListener m√∂glicherweise nicht verf√ºgbar");
                    return false;
                }
                
                // 3. HttpListener Support Check
                if (!HttpListener.IsSupported)
                {
                    StatusChanged?.Invoke("‚ùå HttpListener wird auf diesem System nicht unterst√ºtzt");
                    return false;
                }
                else
                {
                    StatusChanged?.Invoke("‚úÖ HttpListener wird unterst√ºtzt");
                }
                
                // 4. Network Interfaces Check
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up)
                    .ToList();
                    
                StatusChanged?.Invoke($"üåê Aktive Netzwerk-Interfaces: {networkInterfaces.Count}");
                
                if (networkInterfaces.Count == 0)
                {
                    StatusChanged?.Invoke("‚ö†Ô∏è Keine aktiven Netzwerk-Interfaces gefunden");
                }
                
                // 5. Port Availability Check
                var portCheck = await CheckPortAvailability(_port);
                if (!portCheck.IsAvailable)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Port {_port} wird verwendet von: {portCheck.ProcessName} (PID: {portCheck.ProcessId})");
                    StatusChanged?.Invoke("üí° Alternative Ports werden automatisch getestet");
                }
                else
                {
                    StatusChanged?.Invoke($"‚úÖ Port {_port} ist verf√ºgbar");
                }
                
                // 6. Firewall Check (ohne Admin-Rechte)
                await CheckFirewallStatusBasic();
                
                StatusChanged?.Invoke("‚úÖ System-Anforderungen-Check abgeschlossen");
                return true;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è System-Check Fehler: {ex.Message}");
                // Auch bei Fehlern weitermachen - nicht kritisch
                return true;
            }
        }
        
        private async Task<PortStatus> CheckPortAvailability(int port)
        {
            try
            {
                var tcpConnections = System.Net.NetworkInformation.IPGlobalProperties
                    .GetIPGlobalProperties()
                    .GetActiveTcpListeners();
                
                var portInUse = tcpConnections.Any(endpoint => endpoint.Port == port);
                
                if (portInUse)
                {
                    // Versuche Process zu finden der den Port verwendet
                    try
                    {
                        var processInfo = new System.Diagnostics.ProcessStartInfo
                        {
                            FileName = "netstat",
                            Arguments = $"-ano | findstr :{port}",
                            UseShellExecute = false,
                            RedirectStandardOutput = true,
                            CreateNoWindow = true
                        };
                        
                        using var process = System.Diagnostics.Process.Start(processInfo);
                        if (process != null)
                        {
                            await process.WaitForExitAsync();
                            var output = await process.StandardOutput.ReadToEndAsync();
                            
                            if (!string.IsNullOrEmpty(output))
                            {
                                var lines = output.Split('\n');
                                var portLine = lines.FirstOrDefault(l => l.Contains($":{port}"));
                                if (portLine != null)
                                {
                                    var parts = portLine.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                                    if (parts.Length > 0 && int.TryParse(parts.Last(), out int pid))
                                    {
                                        try
                                        {
                                            var proc = System.Diagnostics.Process.GetProcessById(pid);
                                            return new PortStatus 
                                            { 
                                                IsAvailable = false, 
                                                ProcessId = pid, 
                                                ProcessName = proc.ProcessName 
                                            };
                                        }
                                        catch
                                        {
                                            return new PortStatus { IsAvailable = false, ProcessId = pid, ProcessName = "Unknown" };
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch
                    {
                        // netstat-Fehler ignorieren
                    }
                    
                    return new PortStatus { IsAvailable = false, ProcessName = "Unknown Process" };
                }
                
                return new PortStatus { IsAvailable = true };
            }
            catch
            {
                return new PortStatus { IsAvailable = true }; // Bei Fehlern annehmen dass verf√ºgbar
            }
        }
        
        private async Task CheckFirewallStatusBasic()
        {
            try
            {
                StatusChanged?.Invoke("üõ°Ô∏è Pr√ºfe grundlegende Firewall-Einstellungen...");
                
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = "advfirewall show allprofiles state",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    
                    if (output.Contains("State                                 OFF"))
                    {
                        StatusChanged?.Invoke("üõ°Ô∏è Windows Firewall ist deaktiviert");
                    }
                    else if (output.Contains("State                                 ON"))
                    {
                        StatusChanged?.Invoke("üõ°Ô∏è Windows Firewall ist aktiv - Port-Freigabe eventuell erforderlich");
                        StatusChanged?.Invoke("üí° Verwenden Sie 'Netzwerk konfigurieren' f√ºr automatische Setup");
                    }
                }
            }
            catch
            {
                StatusChanged?.Invoke("üõ°Ô∏è Firewall-Status konnte nicht ermittelt werden");
            }
        }
        
        private class PortStatus
        {
            public bool IsAvailable { get; set; }
            public int ProcessId { get; set; }
            public string ProcessName { get; set; } = "";
        }

        private async Task ConfigureNetworkAccessWithoutAdmin()
        {
            try
            {
                StatusChanged?.Invoke("üîß Nicht-Admin Netzwerk-Konfiguration...");
                
                // 1. Pr√ºfe ob URL Reservations bereits existieren
                StatusChanged?.Invoke("üîç Pr√ºfe bestehende URL-Reservierungen...");
                var hasUrlReservation = await CheckExistingUrlReservation();
                if (hasUrlReservation)
                {
                    StatusChanged?.Invoke("‚úÖ URL-Reservierung bereits vorhanden (von vorheriger Admin-Session)");
                }
                
                // 2. Pr√ºfe Windows Firewall Status
                StatusChanged?.Invoke("üõ°Ô∏è Pr√ºfe Windows Firewall...");
                var firewallStatus = await CheckFirewallStatus();
                StatusChanged?.Invoke($"üõ°Ô∏è Firewall Status: {firewallStatus}");
                
                // 3. Versuche Windows Mobile Hotspot Integration
                StatusChanged?.Invoke("üì° Versuche Windows Mobile Hotspot Integration...");
                var hotspotSuccess = await TryWindowsHotspotIntegration();
                
                // 4. Versuche User-Level Konfiguration
                await TryUserLevelConfiguration();
                
                // 5. Gebe erweiterte Benutzer-Anweisungen
                await ProvideEnhancedUserInstructions(hotspotSuccess);
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Nicht-Admin-Konfiguration Fehler: {ex.Message}");
            }
        }
        
        private async Task<bool> CheckExistingUrlReservation()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = "http show urlacl",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    
                    return output.Contains($":{_port}/") || output.Contains($"+:{_port}");
                }
                return false;
            }
            catch
            {
                return false;
            }
        }
        
        private async Task<string> CheckFirewallStatus()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = "advfirewall show allprofiles state",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    
                    if (output.Contains("State                                 OFF"))
                    {
                        return "Deaktiviert (alle Profile)";
                    }
                    else if (output.Contains("State                                 ON"))
                    {
                        return "Aktiviert - Port-Freigabe eventuell erforderlich";
                    }
                    else
                    {
                        return "Status unbekannt";
                    }
                }
                return "Nicht ermittelbar";
            }
            catch
            {
                return "Fehler bei Abfrage";
            }
        }
        
        private async Task TryUserLevelConfiguration()
        {
            try
            {
                StatusChanged?.Invoke("üîß Versuche User-Level-Konfiguration...");
                
                // Erstelle User-spezifische Temp-Konfiguration
                var tempConfigPath = Path.Combine(Path.GetTempPath(), "EinsatzueberwachungMobile");
                Directory.CreateDirectory(tempConfigPath);
                
                var configFile = Path.Combine(tempConfigPath, "network_config.txt");
                var configContent = $@"Einsatz√ºberwachung Mobile - Netzwerk-Konfiguration
Erstellt: {DateTime.Now}
Port: {_port}
IP: {_localIPAddress}
Status: User-Level-Konfiguration aktiv
";
                await File.WriteAllTextAsync(configFile, configContent);
                StatusChanged?.Invoke($"üíæ User-Konfiguration gespeichert: {configFile}");
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è User-Level-Konfiguration Fehler: {ex.Message}");
            }
        }
        
        private async Task ProvideUserInstructions()
        {
            await Task.Delay(100); // Ensure UI updates
            
            StatusChanged?.Invoke("üìã NICHT-ADMIN ANWEISUNGEN:");
            StatusChanged?.Invoke("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            StatusChanged?.Invoke("‚îÇ üîß Manuelle Schritte f√ºr iPhone-Zugriff:   ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 1Ô∏è‚É£ Windows Firewall konfigurieren:          ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows-Einstellungen ‚Üí Update & Sicherheit");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows-Sicherheit ‚Üí Firewall         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ App durch Firewall zulassen           ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Einsatz√ºberwachung ausw√§hlen          ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 2Ô∏è‚É£ Router-Einstellungen pr√ºfen:             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Client-Isolation deaktivieren         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ AP-Isolation deaktivieren             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 3Ô∏è‚É£ Alternative: Hotspot verwenden:          ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows Hotspot aktivieren            ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ iPhone mit Hotspot verbinden          ‚îÇ");
            StatusChanged?.Invoke("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
        }
        
        private async Task ProvideEnhancedUserInstructions(bool hotspotAvailable)
        {
            await Task.Delay(100);
            
            StatusChanged?.Invoke("üìã ERWEITERTE NICHT-ADMIN L√ñSUNGEN:");
            StatusChanged?.Invoke("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            StatusChanged?.Invoke("‚îÇ üéØ EMPFOHLENE L√ñSUNG (einfachste):          ‚îÇ");
            
            if (hotspotAvailable)
            {
                StatusChanged?.Invoke("‚îÇ ‚úÖ Windows Mobile Hotspot (siehe oben)      ‚îÇ");
                StatusChanged?.Invoke("‚îÇ    ‚Üí Funktioniert OHNE Administrator!      ‚îÇ");
            }
            else
            {
                StatusChanged?.Invoke("‚îÇ üì± Smartphone als Hotspot verwenden:       ‚îÇ");
                StatusChanged?.Invoke("‚îÇ    ‚Üí iPhone Hotspot aktivieren             ‚îÇ");
                StatusChanged?.Invoke("‚îÇ    ‚Üí Desktop mit iPhone-Hotspot verbinden  ‚îÇ");
                StatusChanged?.Invoke("‚îÇ    ‚Üí URL: http://172.20.10.1:8080/mobile   ‚îÇ");
            }
            
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ üîß ALTERNATIVE L√ñSUNGEN:                    ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 1Ô∏è‚É£ Windows Firewall √ºber GUI:               ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Systemsteuerung ‚Üí System & Sicherheit ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows Defender Firewall             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Eine App durch die Firewall zulassen  ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Einsatz√ºberwachung hinzuf√ºgen         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 2Ô∏è‚É£ Router-basierte L√∂sung:                  ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Router-Webinterface √∂ffnen            ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ WLAN-Einstellungen ‚Üí Erweitert        ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Client-Isolation deaktivieren         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ AP-Isolation deaktivieren             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 3Ô∏è‚É£ Netzwerk-Profil √§ndern:                  ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows-Einstellungen ‚Üí Netzwerk      ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Aktuelles Netzwerk ‚Üí Eigenschaften    ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Netzwerkprofil: Privat ausw√§hlen      ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 4Ô∏è‚É£ Tempor√§re Firewall-Deaktivierung:       ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Nur f√ºr Tests empfohlen!              ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Windows-Sicherheit ‚Üí Firewall         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Firewall tempor√§r deaktivieren        ‚îÇ");
            StatusChanged?.Invoke("‚îÇ    ‚Ä¢ Nach Test wieder aktivieren!          ‚îÇ");
            StatusChanged?.Invoke("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
            
            StatusChanged?.Invoke("üí° ERFOLGS-TIPPS:");
            StatusChanged?.Invoke($"   ‚Ä¢ Desktop-Test zuerst: http://localhost:{_port}/mobile");
            StatusChanged?.Invoke($"   ‚Ä¢ Debug-Seite nutzen: http://localhost:{_port}/debug");
            StatusChanged?.Invoke("   ‚Ä¢ API-Test Button f√ºr Diagnose verwenden");
            StatusChanged?.Invoke("   ‚Ä¢ Bei Erfolg: Als Administrator starten f√ºr automatische Konfiguration");
        }
        
        private async Task<bool> ConfigurePrefixes()
        {
            bool networkAccessConfigured = false;
            
            // Strategie 1: Spezifische IP-Adresse (funktioniert oft ohne Admin)
            if (_localIPAddress != "localhost" && !string.IsNullOrEmpty(_localIPAddress))
            {
                try
                {
                    _httpListener.Prefixes.Add($"http://{_localIPAddress}:{_port}/");
                    StatusChanged?.Invoke($"‚úÖ Spezifische IP hinzugef√ºgt: {_localIPAddress}:{_port}");
                    networkAccessConfigured = true;
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Spezifische IP Fehler: {ex.Message}");
                }
            }
            
            // Strategie 2: Wildcard (nur mit Admin-Rechten)
            if (IsRunningAsAdministrator())
            {
                try
                {
                    _httpListener.Prefixes.Add($"http://+:{_port}/");
                    StatusChanged?.Invoke($"‚úÖ Wildcard-Prefix hinzugef√ºgt: +:{_port}");
                    networkAccessConfigured = true;
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Wildcard-Prefix Fehler: {ex.Message}");
                }
            }
            
            // Strategie 3: Alle verf√ºgbaren IP-Adressen einzeln (ohne Admin m√∂glich)
            await AddAllAvailableIPs();
            
            // Strategie 4: Localhost-Fallback (immer m√∂glich)
            try
            {
                _httpListener.Prefixes.Add($"http://localhost:{_port}/");
                _httpListener.Prefixes.Add($"http://127.0.0.1:{_port}/");
                StatusChanged?.Invoke($"‚úÖ Localhost-Prefixes hinzugef√ºgt");
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Localhost-Prefix Fehler: {ex.Message}");
            }
            
            return networkAccessConfigured;
        }
        
        private async Task AddAllAvailableIPs()
        {
            try
            {
                StatusChanged?.Invoke("üîç F√ºge alle verf√ºgbaren IP-Adressen hinzu...");
                
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up && 
                               ni.NetworkInterfaceType != NetworkInterfaceType.Loopback);
                
                foreach (var ni in networkInterfaces)
                {
                    var ipProperties = ni.GetIPProperties();
                    var ipAddresses = ipProperties.UnicastAddresses
                        .Where(addr => addr.Address.AddressFamily == AddressFamily.InterNetwork && 
                                     !IPAddress.IsLoopback(addr.Address))
                        .Select(addr => addr.Address);
                    
                    foreach (var ip in ipAddresses)
                    {
                        try
                        {
                            var prefix = $"http://{ip}:{_port}/";
                            if (!_httpListener.Prefixes.Contains(prefix))
                            {
                                _httpListener.Prefixes.Add(prefix);
                                StatusChanged?.Invoke($"‚úÖ IP hinzugef√ºgt: {ip} ({ni.Name})");
                            }
                        }
                        catch (Exception ex)
                        {
                            StatusChanged?.Invoke($"‚ö†Ô∏è IP {ip} Fehler: {ex.Message}");
                        }
                    }
                }
                
                await Task.Delay(100); // UI update time
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è IP-Enumeration Fehler: {ex.Message}");
            }
        }
        
        private async Task TestNetworkReachability()
        {
            try
            {
                StatusChanged?.Invoke("üîç Teste Netzwerk-Erreichbarkeit...");
                
                // Teste localhost
                var localSuccess = await TestEndpoint($"http://localhost:{_port}/test");
                StatusChanged?.Invoke($"üíª Localhost-Test: {(localSuccess ? "‚úÖ OK" : "‚ùå Fehlgeschlagen")}");
                
                // Teste Netzwerk-IP
                if (_localIPAddress != "localhost")
                {
                    var networkSuccess = await TestEndpoint($"http://{_localIPAddress}:{_port}/test");
                    StatusChanged?.Invoke($"üì± Netzwerk-Test: {(networkSuccess ? "‚úÖ OK - iPhone-Zugriff m√∂glich" : "‚ùå Fehlgeschlagen - nur Localhost")}");
                }
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Netzwerk-Test Fehler: {ex.Message}");
            }
        }
        
        private async Task<bool> TestEndpoint(string url)
        {
            try
            {
                using var client = new System.Net.Http.HttpClient();
                client.Timeout = TimeSpan.FromSeconds(2);
                var response = await client.GetAsync(url);
                return response.IsSuccessStatusCode;
            }
            catch
            {
                return false;
            }
        }
        
        private async Task<bool> TryAlternativeServerMethods()
        {
            try
            {
                StatusChanged?.Invoke("üîÑ Versuche alternative Server-Methoden...");
                
                // Methode 1: Nur spezifische IP ohne Wildcard
                await TrySpecificIPOnly();
                
                // Methode 2: Alternativer Port
                if (!_isRunning)
                {
                    await TryAlternativePort();
                }
                
                // Methode 3: Minimaler Localhost-Server
                if (!_isRunning)
                {
                    await TryMinimalLocalhost();
                }
                
                return _isRunning;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Alternative Methoden fehlgeschlagen: {ex.Message}");
                return false;
            }
        }
        
        private async Task TrySpecificIPOnly()
        {
            try
            {
                StatusChanged?.Invoke("üîÑ Versuche spezifische IP ohne Admin-Rechte...");
                
                _httpListener?.Close();
                _httpListener = new HttpListener();
                
                if (_localIPAddress != "localhost")
                {
                    _httpListener.Prefixes.Add($"http://{_localIPAddress}:{_port}/");
                }
                _httpListener.Prefixes.Add($"http://localhost:{_port}/");
                
                _httpListener.Start();
                _isRunning = true;
                
                StatusChanged?.Invoke("‚úÖ Spezifische IP-Methode erfolgreich!");
                _ = Task.Run(HandleRequestsAsync);
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Spezifische IP-Methode fehlgeschlagen: {ex.Message}");
            }
        }
        
        private async Task TryAlternativePort()
        {
            var alternativePorts = new[] { 8081, 8082, 8083, 9000, 9001 };
            
            foreach (var port in alternativePorts)
            {
                try
                {
                    StatusChanged?.Invoke($"üîÑ Versuche alternativen Port: {port}");
                    
                    _httpListener?.Close();
                    _httpListener = new HttpListener();
                    _httpListener.Prefixes.Add($"http://localhost:{port}/");
                    
                    if (_localIPAddress != "localhost")
                    {
                        _httpListener.Prefixes.Add($"http://{_localIPAddress}:{port}/");
                    }
                    
                    _httpListener.Start();
                    _isRunning = true;
                    
                    // Update port for future reference
                    var originalPort = _port;
                    // _port = port; // Uncomment if you want to permanently change port
                    
                    StatusChanged?.Invoke($"‚úÖ Alternativer Port {port} erfolgreich!");
                    StatusChanged?.Invoke($"üì± Neue iPhone URL: http://{_localIPAddress}:{port}/mobile");
                    StatusChanged?.Invoke($"üíª Neue Desktop URL: http://localhost:{port}/mobile");
                    
                    _ = Task.Run(HandleRequestsAsync);
                    return;
                    
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Port {port} fehlgeschlagen: {ex.Message}");
                }
            }
        }
        
        private async Task TryMinimalLocalhost()
        {
            try
            {
                StatusChanged?.Invoke("üîÑ Minimaler Localhost-Server als letzter Ausweg...");
                
                _httpListener?.Close();
                _httpListener = new HttpListener();
                _httpListener.Prefixes.Add($"http://localhost:{_port}/");
                
                _httpListener.Start();
                _isRunning = true;
                
                StatusChanged?.Invoke("‚úÖ Minimaler Localhost-Server gestartet");
                StatusChanged?.Invoke("‚ö†Ô∏è Nur Desktop-Zugriff m√∂glich");
                StatusChanged?.Invoke("üí° F√ºr iPhone: Manuelle Firewall-Konfiguration erforderlich");
                
                _ = Task.Run(HandleRequestsAsync);
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Minimaler Server fehlgeschlagen: {ex.Message}");
            }
        }

        private async Task<bool> TryWindowsHotspotIntegration()
        {
            try
            {
                StatusChanged?.Invoke("üì° Pr√ºfe Windows Mobile Hotspot...");
                
                // Pr√ºfe ob Mobile Hotspot verf√ºgbar ist
                var hotspotStatus = await CheckMobileHotspotStatus();
                
                if (hotspotStatus.IsAvailable)
                {
                    StatusChanged?.Invoke("‚úÖ Windows Mobile Hotspot verf√ºgbar");
                    
                    if (hotspotStatus.IsActive)
                    {
                        StatusChanged?.Invoke("üî• Mobile Hotspot bereits aktiv");
                        StatusChanged?.Invoke($"üì± Hotspot-Name: {hotspotStatus.NetworkName}");
                        StatusChanged?.Invoke("üí° Verbinden Sie Ihr iPhone mit diesem Hotspot");
                        
                        // Verwende Hotspot-IP
                        var hotspotIP = await GetHotspotIPAddress();
                        if (!string.IsNullOrEmpty(hotspotIP))
                        {
                            try
                            {
                                _httpListener.Prefixes.Add($"http://{hotspotIP}:{_port}/");
                                StatusChanged?.Invoke($"‚úÖ Hotspot-IP hinzugef√ºgt: {hotspotIP}");
                                return true;
                            }
                            catch (Exception ex)
                            {
                                StatusChanged?.Invoke($"‚ö†Ô∏è Hotspot-IP Fehler: {ex.Message}");
                            }
                        }
                    }
                    else
                    {
                        StatusChanged?.Invoke("üí° Tipp: Aktivieren Sie den Windows Mobile Hotspot f√ºr iPhone-Zugriff");
                        StatusChanged?.Invoke("   Settings ‚Üí Network & Internet ‚Üí Mobile hotspot");
                        return await ProvideHotspotInstructions();
                    }
                }
                else
                {
                    StatusChanged?.Invoke("‚ö†Ô∏è Windows Mobile Hotspot nicht verf√ºgbar auf diesem System");
                }
                
                return false;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Hotspot-Integration Fehler: {ex.Message}");
                return false;
            }
        }
        
        private async Task<HotspotStatus> CheckMobileHotspotStatus()
        {
            try
            {
                // Verwende PowerShell um Hotspot-Status zu pr√ºfen
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = "-Command \"Get-NetAdapter | Where-Object {$_.InterfaceDescription -like '*Microsoft Wi-Fi Direct Virtual Adapter*'}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    
                    var isAvailable = !string.IsNullOrEmpty(output.Trim());
                    var isActive = output.Contains("Up") || output.Contains("Connected");
                    
                    return new HotspotStatus
                    {
                        IsAvailable = isAvailable,
                        IsActive = isActive,
                        NetworkName = isActive ? await GetHotspotNetworkName() : ""
                    };
                }
                
                return new HotspotStatus { IsAvailable = false, IsActive = false };
            }
            catch
            {
                return new HotspotStatus { IsAvailable = false, IsActive = false };
            }
        }
        
        private async Task<string> GetHotspotNetworkName()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = "wlan show profiles",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    
                    // Suche nach aktuell aktivem Hotspot
                    var lines = output.Split('\n');
                    foreach (var line in lines)
                    {
                        if (line.Contains("All User Profile") && line.Contains("*"))
                        {
                            var parts = line.Split(':');
                            if (parts.Length > 1)
                            {
                                return parts[1].Trim();
                            }
                        }
                    }
                }
                
                return "Windows Hotspot";
            }
            catch
            {
                return "Windows Hotspot";
            }
        }
        
        private async Task<string> GetHotspotIPAddress()
        {
            try
            {
                // Suche nach der Mobile Hotspot IP (normalerweise 192.168.137.1)
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
                
                foreach (var ni in networkInterfaces)
                {
                    if (ni.Description.Contains("Microsoft Wi-Fi Direct Virtual Adapter") ||
                        ni.Name.Contains("Local Area Connection") && ni.OperationalStatus == OperationalStatus.Up)
                    {
                        var ipProperties = ni.GetIPProperties();
                        var ipAddress = ipProperties.UnicastAddresses
                            .FirstOrDefault(addr => addr.Address.AddressFamily == AddressFamily.InterNetwork &&
                                                  addr.Address.ToString().StartsWith("192.168.137."));
                        
                        if (ipAddress != null)
                        {
                            return ipAddress.Address.ToString();
                        }
                    }
                }
                
                // Fallback: Standard Hotspot IP
                return "192.168.137.1";
            }
            catch
            {
                return "192.168.137.1";
            }
        }
        
        private async Task<bool> ProvideHotspotInstructions()
        {
            await Task.Delay(100);
            
            StatusChanged?.Invoke("üì≤ WINDOWS HOTSPOT ANWEISUNGEN (OHNE ADMIN):");
            StatusChanged?.Invoke("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            StatusChanged?.Invoke("‚îÇ üî• Windows Mobile Hotspot aktivieren:       ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 1Ô∏è‚É£ Windows-Einstellungen √∂ffnen (Win+I)     ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 2Ô∏è‚É£ Netzwerk und Internet                    ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 3Ô∏è‚É£ Mobiler Hotspot                         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 4Ô∏è‚É£ Mobilen Hotspot aktivieren              ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 5Ô∏è‚É£ WLAN-Name und Passwort notieren         ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ üì± iPhone-Verbindung:                       ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 1Ô∏è‚É£ iPhone WLAN-Einstellungen               ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 2Ô∏è‚É£ Windows Hotspot-Name w√§hlen             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 3Ô∏è‚É£ Passwort eingeben                       ‚îÇ");
            StatusChanged?.Invoke("‚îÇ 4Ô∏è‚É£ Verbinden                               ‚îÇ");
            StatusChanged?.Invoke("‚îÇ                                             ‚îÇ");
            StatusChanged?.Invoke("‚îÇ üåê URL: http://192.168.137.1:8080/mobile   ‚îÇ");
            StatusChanged?.Invoke("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
            
            return true;
        }
        
        private class HotspotStatus
        {
            public bool IsAvailable { get; set; }
            public bool IsActive { get; set; }
            public string NetworkName { get; set; } = "";
        }

        private void CheckFirewallAndNetwork()
        {
            try
            {
                StatusChanged?.Invoke("üõ°Ô∏è Pr√ºfe Firewall und Netzwerk...");
                
                // Pr√ºfe ob Port 8080 bereits verwendet wird
                var tcpConnections = System.Net.NetworkInformation.IPGlobalProperties
                    .GetIPGlobalProperties()
                    .GetActiveTcpListeners();
                
                var portInUse = tcpConnections.Any(endpoint => endpoint.Port == _port);
                if (portInUse)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Port {_port} wird bereits verwendet!");
                }
                else
                {
                    StatusChanged?.Invoke($"‚úÖ Port {_port} ist verf√ºgbar");
                }
                
                // Pr√ºfe Windows-Version und Admin-Rechte
                var isAdmin = IsRunningAsAdministrator();
                StatusChanged?.Invoke($"üîê Administrator-Rechte: {(isAdmin ? "‚úÖ Ja" : "‚ùå Nein")}");
                
                if (!isAdmin)
                {
                    StatusChanged?.Invoke("üí° Tipp: Als Administrator starten f√ºr iPhone-Zugriff!");
                }
                
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Firewall-Check Fehler: {ex.Message}");
            }
        }
        
        private bool IsRunningAsAdministrator()
        {
            try
            {
                var identity = System.Security.Principal.WindowsIdentity.GetCurrent();
                var principal = new System.Security.Principal.WindowsPrincipal(identity);
                return principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);
            }
            catch
            {
                return false;
            }
        }

        private async Task<bool> ConfigureNetworkAccess()
        {
            try
            {
                StatusChanged?.Invoke("üîß Konfiguriere automatischen Netzwerk-Zugriff...");
                
                if (!IsRunningAsAdministrator())
                {
                    StatusChanged?.Invoke("‚ö†Ô∏è Keine Administrator-Rechte - Netzwerk-Konfiguration √ºbersprungen");
                    return false;
                }
                
                bool success = true;
                
                // 1. HTTP URL Reservation hinzuf√ºgen
                success &= await AddHttpUrlReservation();
                
                // 2. Firewall-Regel hinzuf√ºgen
                success &= await AddFirewallRule();
                
                if (success)
                {
                    StatusChanged?.Invoke("‚úÖ Automatische Netzwerk-Konfiguration erfolgreich!");
                }
                else
                {
                    StatusChanged?.Invoke("‚ö†Ô∏è Netzwerk-Konfiguration teilweise fehlgeschlagen");
                }
                
                return success;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Netzwerk-Konfiguration Fehler: {ex.Message}");
                return false;
            }
        }
        
        private async Task<bool> AddHttpUrlReservation()
        {
            try
            {
                StatusChanged?.Invoke("üîó F√ºge HTTP URL Reservation hinzu...");
                
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = $"http add urlacl url=http://+:{_port}/ user=Everyone",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    Verb = "runas" // Stellt sicher, dass es mit Admin-Rechten l√§uft
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    var output = await process.StandardOutput.ReadToEndAsync();
                    var error = await process.StandardError.ReadToEndAsync();
                    
                    if (process.ExitCode == 0 || output.Contains("already exists"))
                    {
                        StatusChanged?.Invoke($"‚úÖ URL Reservation: http://+:{_port}/");
                        return true;
                    }
                    else
                    {
                        StatusChanged?.Invoke($"‚ö†Ô∏è URL Reservation Warnung: {error}");
                        return false;
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è URL Reservation Fehler: {ex.Message}");
                return false;
            }
        }
        
        private async Task<bool> AddFirewallRule()
        {
            try
            {
                StatusChanged?.Invoke("üõ°Ô∏è F√ºge Firewall-Regel hinzu...");
                
                var ruleName = "Einsatzueberwachung_Mobile";
                
                // Pr√ºfe erst ob Regel bereits existiert
                var checkProcessInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = $"advfirewall firewall show rule name=\"{ruleName}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                
                using var checkProcess = System.Diagnostics.Process.Start(checkProcessInfo);
                if (checkProcess != null)
                {
                    await checkProcess.WaitForExitAsync();
                    var checkOutput = await checkProcess.StandardOutput.ReadToEndAsync();
                    
                    if (checkOutput.Contains(ruleName))
                    {
                        StatusChanged?.Invoke("‚úÖ Firewall-Regel bereits vorhanden");
                        return true;
                    }
                }
                
                // F√ºge neue Regel hinzu
                var addProcessInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = $"advfirewall firewall add rule name=\"{ruleName}\" dir=in action=allow protocol=TCP localport={_port}",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                
                using var addProcess = System.Diagnostics.Process.Start(addProcessInfo);
                if (addProcess != null)
                {
                    await addProcess.WaitForExitAsync();
                    var output = await addProcess.StandardOutput.ReadToEndAsync();
                    var error = await addProcess.StandardError.ReadToEndAsync();
                    
                    if (addProcess.ExitCode == 0)
                    {
                        StatusChanged?.Invoke($"‚úÖ Firewall-Regel hinzugef√ºgt: {ruleName} (Port {_port})");
                        return true;
                    }
                    else
                    {
                        StatusChanged?.Invoke($"‚ö†Ô∏è Firewall-Regel Warnung: {error}");
                        return false;
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ö†Ô∏è Firewall-Regel Fehler: {ex.Message}");
                return false;
            }
        }

        public void StopServer()
        {
            try
            {
                StatusChanged?.Invoke("üõë Stoppe Mobile Server...");
                
                _isRunning = false;
                _httpListener?.Stop();
                _httpListener?.Close();
                _httpListener = null;
                
                StatusChanged?.Invoke("‚úÖ Mobile Server gestoppt");
                StatusChanged?.Invoke("üí° Netzwerk-Konfiguration bleibt f√ºr zuk√ºnftige Sessions bestehen");
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Fehler beim Stoppen des Servers: {ex.Message}");
            }
        }
        
        public async Task<bool> CleanupNetworkConfiguration()
        {
            try
            {
                if (!IsRunningAsAdministrator())
                {
                    StatusChanged?.Invoke("‚ö†Ô∏è Administrator-Rechte erforderlich f√ºr Netzwerk-Cleanup");
                    return false;
                }
                
                StatusChanged?.Invoke("üßπ Bereinige Netzwerk-Konfiguration...");
                
                bool success = true;
                
                // URL Reservation entfernen
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = $"http delete urlacl url=http://+:{_port}/",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                
                using var process = System.Diagnostics.Process.Start(processInfo);
                if (process != null)
                {
                    await process.WaitForExitAsync();
                    if (process.ExitCode == 0)
                    {
                        StatusChanged?.Invoke("‚úÖ URL Reservation entfernt");
                    }
                    else
                    {
                        StatusChanged?.Invoke("‚ö†Ô∏è URL Reservation nicht gefunden oder bereits entfernt");
                    }
                }
                
                // Firewall-Regel entfernen (optional)
                var firewallProcessInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = "advfirewall firewall delete rule name=\"Einsatzueberwachung_Mobile\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                
                using var firewallProcess = System.Diagnostics.Process.Start(firewallProcessInfo);
                if (firewallProcess != null)
                {
                    await firewallProcess.WaitForExitAsync();
                    if (firewallProcess.ExitCode == 0)
                    {
                        StatusChanged?.Invoke("‚úÖ Firewall-Regel entfernt");
                    }
                    else
                    {
                        StatusChanged?.Invoke("‚ö†Ô∏è Firewall-Regel nicht gefunden oder bereits entfernt");
                    }
                }
                
                return success;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"‚ùå Cleanup Fehler: {ex.Message}");
                return false;
            }
        }

        private async Task HandleRequestsAsync()
        {
            while (_isRunning && _httpListener != null)
            {
                try
                {
                    var context = await _httpListener.GetContextAsync();
                    _ = Task.Run(() => ProcessRequest(context));
                }
                catch (HttpListenerException ex) when (!_isRunning)
                {
                    // Expected exception when server is stopping
                    break;
                }
                catch (ObjectDisposedException) when (!_isRunning)
                {
                    // Expected exception when server is disposed
                    break;
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"Server-Fehler: {ex.Message}");
                    // Continue running unless critical error
                    if (!_isRunning) break;
                }
            }
        }

        private void ProcessRequest(HttpListenerContext context)
        {
            var request = context.Request;
            var response = context.Response;
            
            try
            {
                // Detailliertes Logging f√ºr Debugging
                var url = request.Url?.ToString() ?? "Unknown URL";
                var method = request.HttpMethod;
                var path = request.Url?.AbsolutePath ?? "/";
                var userAgent = request.UserAgent ?? "Unknown";
                
                StatusChanged?.Invoke($"üì± {method} {path} from {userAgent}");
                
                // Setze Standard-Headers f√ºr alle Responses
                response.Headers.Add("Server", "Einsatzueberwachung-Mobile/1.6");
                response.Headers.Add("Access-Control-Allow-Origin", "*");
                response.Headers.Add("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
                response.Headers.Add("Access-Control-Allow-Headers", "Content-Type, Accept");
                
                // Handle OPTIONS preflight requests (CORS)
                if (request.HttpMethod.Equals("OPTIONS", StringComparison.OrdinalIgnoreCase))
                {
                    response.StatusCode = 200;
                    response.ContentLength64 = 0;
                    StatusChanged?.Invoke("‚úÖ CORS preflight handled");
                    return;
                }
                
                // Normalisiere den Path
                path = path.TrimEnd('/');
                if (string.IsNullOrEmpty(path))
                    path = "/mobile"; // Default
                
                StatusChanged?.Invoke($"üîÑ Processing path: {path}");
                
                switch (path.ToLowerInvariant())
                {
                    case "":
                    case "/":
                        // Redirect to mobile interface
                        response.StatusCode = 302;
                        response.Headers.Add("Location", "/mobile");
                        response.ContentLength64 = 0;
                        StatusChanged?.Invoke("‚Ü©Ô∏è Redirected to /mobile");
                        return;
                        
                    case "/mobile":
                        ServeMobileInterface(response);
                        StatusChanged?.Invoke("‚úÖ Mobile interface served");
                        break;
                        
                    case "/api/status":
                        ServeApiStatus(response);
                        StatusChanged?.Invoke("‚úÖ API status served");
                        break;
                        
                    case "/api/teams":
                        ServeApiTeams(response);
                        StatusChanged?.Invoke("‚úÖ API teams served");
                        break;
                        
                    case "/api/notes":
                        ServeApiNotes(response);
                        StatusChanged?.Invoke("‚úÖ API notes served");
                        break;
                        
                    case "/test":
                    case "/ping":
                        ServeTestResponse(response);
                        StatusChanged?.Invoke("‚úÖ Test endpoint served");
                        break;

                    case "/debug":
                        ServeDebugPage(response);
                        StatusChanged?.Invoke("‚úÖ Debug page served");
                        break;
                        
                    case "/qr":
                    case "/qr.png":
                        ServeQRCode(response);
                        StatusChanged?.Invoke("‚úÖ QR code served");
                        break;
                        
                    case "/favicon.ico":
                        // Return empty favicon to avoid 404s
                        response.StatusCode = 204;
                        response.ContentLength64 = 0;
                        StatusChanged?.Invoke("üìÑ Favicon request ignored");
                        return;
                        
                    default:
                        StatusChanged?.Invoke($"‚ùå Unknown path: {path}");
                        ServeError(response, 404, $"Path not found: {path}");
                        break;
                }
            }
            catch (HttpListenerException ex)
            {
                StatusChanged?.Invoke($"üö® HttpListener Exception: {ex.ErrorCode} - {ex.Message}");
                try
                {
                    if (ex.ErrorCode == 1229) // Connection was forcibly closed
                    {
                        StatusChanged?.Invoke("‚ö†Ô∏è Client disconnected");
                        return;
                    }
                    ServeError(response, 500, $"Network error: {ex.Message}");
                }
                catch { /* Ignore secondary errors */ }
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"üö® Server Exception: {ex.GetType().Name} - {ex.Message}");
                try
                {
                    ServeError(response, 500, $"Server error: {ex.Message}");
                }
                catch { /* Ignore secondary errors */ }
            }
            finally
            {
                try
                {
                    response?.Close();
                }
                catch (Exception ex)
                {
                    StatusChanged?.Invoke($"‚ö†Ô∏è Response close error: {ex.Message}");
                }
            }
        }

        private void ServeMobileInterface(HttpListenerResponse response)
        {
            try
            {
                StatusChanged?.Invoke("üîÑ Generating mobile HTML...");
                var html = GenerateMobileHTML();
                
                if (string.IsNullOrEmpty(html))
                {
                    StatusChanged?.Invoke("‚ùå Generated HTML is empty!");
                    ServeError(response, 500, "Failed to generate mobile interface");
                    return;
                }
                
                var buffer = Encoding.UTF8.GetBytes(html);
                StatusChanged?.Invoke($"üìÑ HTML size: {buffer.Length} bytes");
                
                // Setze Response Headers
                response.StatusCode = 200;
                response.ContentType = "text/html; charset=utf-8";
                response.ContentLength64 = buffer.Length;
                response.Headers.Add("Cache-Control", "no-cache, no-store, must-revalidate");
                response.Headers.Add("Pragma", "no-cache");
                response.Headers.Add("Expires", "0");
                
                StatusChanged?.Invoke("üì§ Writing HTML response...");
                
                // Schreibe Content in kleinen Chunks f√ºr bessere Fehlerbehandlung
                int bytesWritten = 0;
                int chunkSize = 8192; // 8KB chunks
                
                while (bytesWritten < buffer.Length)
                {
                    int remainingBytes = buffer.Length - bytesWritten;
                    int currentChunkSize = Math.Min(chunkSize, remainingBytes);
                    
                    response.OutputStream.Write(buffer, bytesWritten, currentChunkSize);
                    bytesWritten += currentChunkSize;
                }
                
                response.OutputStream.Flush();
                StatusChanged?.Invoke($"‚úÖ Mobile interface delivered successfully ({bytesWritten} bytes)");
            }
            catch (HttpListenerException ex)
            {
                StatusChanged?.Invoke($"üö® HTTP error serving mobile interface: {ex.ErrorCode} - {ex.Message}");
                throw;
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"üö® Error serving mobile interface: {ex.GetType().Name} - {ex.Message}");
                throw;
            }
        }

        private void ServeApiStatus(HttpListenerResponse response)
        {
            var einsatzData = GetEinsatzData?.Invoke();
            var teams = GetCurrentTeams?.Invoke() ?? new List<Team>();
            
            var status = new
            {
                server = "Einsatz√ºberwachung Mobile API",
                version = "1.6",
                timestamp = DateTime.Now,
                active = true,
                serverIP = _localIPAddress,
                mission = new
                {
                    location = einsatzData?.Einsatzort ?? "Unbekannt",
                    leader = einsatzData?.Einsatzleiter ?? "Unbekannt",
                    startTime = einsatzData?.EinsatzDatum ?? DateTime.Now,
                    duration = einsatzData != null ? DateTime.Now.Subtract(einsatzData.EinsatzDatum).ToString(@"hh\:mm\:ss") : "00:00:00"
                },
                teamCount = teams.Count,
                activeTeams = teams.Count(t => t.IsRunning)
            };
            
            ServeJson(response, status);
        }

        private void ServeApiTeams(HttpListenerResponse response)
        {
            try
            {
                var teams = GetCurrentTeams?.Invoke() ?? new List<Team>();
                
                var teamData = teams.Select(team => new
                {
                    id = team.TeamId,
                    name = team.TeamName,
                    dogName = team.HundName,
                    handler = team.Hundefuehrer,
                    helper = team.Helfer,
                    types = team.MultipleTeamTypes?.SelectedTypes?.Select(t => t.ToString()).ToArray() ?? new[] { team.TeamType.ToString() },
                    typeDisplay = team.TeamTypeDisplayName,
                    status = team.IsRunning ? "active" : "ready",
                    time = team.ElapsedTimeString,
                    isFirstWarning = team.IsFirstWarning,
                    isSecondWarning = team.IsSecondWarning,
                    firstWarningMinutes = team.FirstWarningMinutes,
                    secondWarningMinutes = team.SecondWarningMinutes,
                    notes = team.NotesEntries?.Take(10).Select(note => new
                    {
                        time = note.Timestamp.ToString("HH:mm"),
                        content = note.Content,
                        type = note.EntryType.ToString()
                    }).ToArray() ?? Array.Empty<object>(),
                    notesCount = team.NotesEntries?.Count ?? 0
                }).ToArray();
                
                ServeJson(response, teamData);
            }
            catch (Exception ex)
            {
                // Fallback to empty array if teams can't be retrieved
                ServeJson(response, Array.Empty<object>());
                StatusChanged?.Invoke($"Fehler beim Laden der Teams: {ex.Message}");
            }
        }

        private void ServeApiNotes(HttpListenerResponse response)
        {
            try
            {
                var teams = GetCurrentTeams?.Invoke() ?? new List<Team>();
                
                var allNotes = teams.SelectMany(team => 
                    team.NotesEntries?.Select(note => new
                    {
                        teamId = team.TeamId,
                        teamName = team.TeamName,
                        time = note.Timestamp.ToString("HH:mm:ss"),
                        content = note.Content,
                        type = note.EntryType.ToString(),
                        timestamp = note.Timestamp
                    }) ?? Enumerable.Empty<object>()
                ).OrderByDescending(note => ((dynamic)note).timestamp)
                .Take(50) // Letzte 50 Notizen
                .ToArray();
                
                ServeJson(response, allNotes);
            }
            catch (Exception ex)
            {
                ServeJson(response, Array.Empty<object>());
                StatusChanged?.Invoke($"Fehler beim Laden der Notizen: {ex.Message}");
            }
        }

        private void ServeTestResponse(HttpListenerResponse response)
        {
            try
            {
                var testData = new
                {
                    status = "OK",
                    message = "Einsatzueberwachung Mobile Server is running",
                    version = "1.6",
                    timestamp = DateTime.Now,
                    server_ip = _localIPAddress,
                    endpoints = new[]
                    {
                        "/mobile - Mobile Web App",
                        "/api/status - Server Status",
                        "/api/teams - Team Data",
                        "/api/notes - Notes Data",
                        "/test - This test endpoint",
                        "/qr - QR Code image"
                    }
                };
                
                ServeJson(response, testData);
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"Error serving test response: {ex.Message}");
                throw;
            }
        }

        private void ServeJson(HttpListenerResponse response, object data)
        {
            try
            {
                var json = JsonSerializer.Serialize(data, new JsonSerializerOptions 
                { 
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                    WriteIndented = true 
                });
                var buffer = Encoding.UTF8.GetBytes(json);
                
                response.StatusCode = 200;
                response.ContentType = "application/json; charset=utf-8";
                response.ContentLength64 = buffer.Length;
                response.Headers.Add("Cache-Control", "no-cache");
                
                response.OutputStream.Write(buffer, 0, buffer.Length);
                response.OutputStream.Flush();
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"Error serving JSON: {ex.Message}");
                throw;
            }
        }

        private void ServeError(HttpListenerResponse response, int statusCode, string message)
        {
            try
            {
                StatusChanged?.Invoke($"üö® Serving error {statusCode}: {message}");
                
                response.StatusCode = statusCode;
                
                var errorResponse = new 
                { 
                    error = message, 
                    statusCode = statusCode,
                    timestamp = DateTime.Now,
                    server = "Einsatzueberwachung Mobile v1.6"
                };
                
                var json = JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions 
                { 
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                    WriteIndented = true 
                });
                
                var buffer = Encoding.UTF8.GetBytes(json);
                
                response.ContentType = "application/json; charset=utf-8";
                response.ContentLength64 = buffer.Length;
                response.Headers.Add("Cache-Control", "no-cache");
                
                response.OutputStream.Write(buffer, 0, buffer.Length);
                response.OutputStream.Flush();
                
                StatusChanged?.Invoke($"üì§ Error response sent: {statusCode}");
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"üö® Failed to send error response: {ex.Message}");
                // Last resort: try to set status code only
                try
                {
                    response.StatusCode = statusCode;
                }
                catch { /* Give up */ }
            }
        }

        private void ServeQRCode(HttpListenerResponse response)
        {
            try
            {
                var qrCodeBytes = GenerateQRCode();
                if (qrCodeBytes.Length > 0)
                {
                    response.ContentType = "image/png";
                    response.ContentLength64 = qrCodeBytes.Length;
                    response.OutputStream.Write(qrCodeBytes, 0, qrCodeBytes.Length);
                }
                else
                {
                    ServeError(response, 500, "QR-Code generation failed");
                }
            }
            catch (Exception ex)
            {
                ServeError(response, 500, $"QR-Code error: {ex.Message}");
            }
        }

        private void ServeDebugPage(HttpListenerResponse response)
        {
            try
            {
                var teams = GetCurrentTeams?.Invoke() ?? new List<Team>();
                var einsatzData = GetEinsatzData?.Invoke();
                
                var debugHtml = $@"<!DOCTYPE html>
<html>
<head>
    <title>üîß Debug - Einsatz√ºberwachung Mobile</title>
    <meta charset='UTF-8'>
    <style>
        body {{ font-family: monospace; margin: 20px; background: #f0f0f0; }}
        .section {{ background: white; margin: 10px 0; padding: 15px; border-radius: 5px; border: 1px solid #ddd; }}
        .ok {{ color: green; }} .error {{ color: red; }} .warning {{ color: orange; }}
        pre {{ background: #f8f8f8; padding: 10px; overflow-x: auto; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <h1>üîß Einsatz√ºberwachung Mobile - Debug Information</h1>
    
    <div class='section'>
        <h2>üìä Server Status</h2>
        <table>
            <tr><th>Property</th><th>Value</th><th>Status</th></tr>
            <tr><td>Server Version</td><td>1.6</td><td class='ok'>‚úÖ OK</td></tr>
            <tr><td>Current Time</td><td>{DateTime.Now:yyyy-MM-dd HH:mm:ss}</td><td class='ok'>‚úÖ OK</td></tr>
            <tr><td>Server IP</td><td>{_localIPAddress}</td><td class='{(_localIPAddress != "localhost" ? "ok" : "warning")}'>
                {(_localIPAddress != "localhost" ? "‚úÖ Network Access" : "‚ö†Ô∏è Localhost Only")}</td></tr>
            <tr><td>Base URL</td><td>{_baseUrl}</td><td class='ok'>‚úÖ OK</td></tr>
            <tr><td>Is Running</td><td>{_isRunning}</td><td class='{(_isRunning ? "ok" : "error")}'>{(_isRunning ? "‚úÖ Running" : "‚ùå Stopped")}</td></tr>
        </table>
    </div>

    <div class='section'>
        <h2>üêï Team Data</h2>
        <table>
            <tr><th>Team Count</th><td>{teams.Count}</td><td class='{(teams.Count > 0 ? "ok" : "warning")}'>{(teams.Count > 0 ? "‚úÖ Teams Available" : "‚ö†Ô∏è No Teams")}</td></tr>
            <tr><th>Active Teams</th><td>{teams.Count(t => t.IsRunning)}</td><td class='ok'>‚úÖ OK</td></tr>
        </table>
        
        {(teams.Count > 0 ? $@"<h3>Team Details:</h3>
        <table>
            <tr><th>ID</th><th>Name</th><th>Dog</th><th>Handler</th><th>Status</th><th>Time</th></tr>
            {string.Join("", teams.Take(5).Select(t => $@"<tr>
                <td>{t.TeamId}</td><td>{t.TeamName}</td><td>{t.HundName}</td><td>{t.Hundefuehrer}</td>
                <td class='{(t.IsRunning ? "ok" : "warning")}'>{(t.IsRunning ? "Active" : "Ready")}</td>
                <td>{t.ElapsedTimeString}</td>
            </tr>"))}
        </table>" : "<p class='warning'>No teams created yet. Add teams in the desktop application.</p>")}
    </div>

    <div class='section'>
        <h2>üìã Mission Data</h2>
        <table>
            <tr><th>Mission Location</th><td>{einsatzData?.Einsatzort ?? "Not Set"}</td></tr>
            <tr><th>Mission Leader</th><td>{einsatzData?.Einsatzleiter ?? "Not Set"}</td></tr>
            <tr><th>Mission Start</th><td>{einsatzData?.EinsatzDatum.ToString("yyyy-MM-dd HH:mm:ss") ?? "Not Set"}</td></tr>
            <tr><th>Mission Duration</th><td>{(einsatzData != null ? DateTime.Now.Subtract(einsatzData.EinsatzDatum).ToString(@"hh\:mm\:ss") : "Not Set")}</td></tr>
        </table>
    </div>

    <div class='section'>
        <h2>üåê API Endpoints</h2>
        <p>Test these URLs in your browser or with curl:</p>
        <ul>
            <li><a href='/mobile'>/mobile</a> - Mobile Web Application</li>
            <li><a href='/api/status'>/api/status</a> - Server Status JSON</li>
            <li><a href='/api/teams'>/api/teams</a> - Teams Data JSON</li>
            <li><a href='/api/notes'>/api/notes</a> - Notes Data JSON</li>
            <li><a href='/test'>/test</a> - Simple Test Endpoint</li>
            <li><a href='/qr'>/qr</a> - QR Code Image</li>
            <li><a href='/debug'>/debug</a> - This Debug Page</li>
        </ul>
    </div>

    <div class='section'>
        <h2>üì± Mobile Access Instructions</h2>
        <ol>
            <li><strong>Same WiFi Network:</strong> Ensure both desktop and mobile device are on the same WiFi</li>
            <li><strong>Correct URL:</strong> Use <code>http://{_localIPAddress}:8080/mobile</code></li>
            <li><strong>No HTTPS:</strong> Use HTTP (not HTTPS) - mobile browsers might auto-correct this</li>
            <li><strong>Clear Cache:</strong> Clear browser cache if you see old content</li>
            <li><strong>Admin Rights:</strong> Run desktop app as Administrator for network access</li>
        </ol>
    </div>

    <div class='section'>
        <h2>üîß Troubleshooting</h2>
        <h3>Common Issues:</h3>
        <ul>
            <li><strong>HTTP 400:</strong> Check URL format - must include '/mobile' suffix</li>
            <li><strong>Connection Refused:</strong> Check Windows Firewall, port 8080 must be open</li>
            <li><strong>Localhost Only:</strong> Run as Administrator for network access</li>
            <li><strong>Blank Page:</strong> Clear browser cache, disable content blockers</li>
        </ul>
        
        <h3>Quick Tests:</h3>
        <ol>
            <li>Test locally: <a href='http://localhost:8080/test'>http://localhost:8080/test</a></li>
            <li>Test mobile endpoint: <a href='/mobile'>/mobile</a></li>
            <li>Test API: <a href='/api/status'>/api/status</a></li>
        </ol>
    </div>

    <div class='section'>
        <h2>üìù Request Log</h2>
        <p><em>Check the Desktop Application's Mobile Connection Window for real-time request logs.</em></p>
        <p>Each request should show: Method, Path, User-Agent, and Result</p>
    </div>

    <script>
        // Auto-refresh every 30 seconds
        setTimeout(() => location.reload(), 30000);
        
        // Add current URL info
        document.addEventListener('DOMContentLoaded', function() {{
            const urlInfo = document.createElement('div');
            urlInfo.className = 'section';
            urlInfo.innerHTML = `<h2>üåê Current Access Info</h2>
                <p><strong>Your Browser URL:</strong> ${{window.location.href}}</p>
                <p><strong>User Agent:</strong> ${{navigator.userAgent}}</p>
                <p><strong>Screen Size:</strong> ${{screen.width}}x${{screen.height}}</p>
                <p><strong>Viewport:</strong> ${{window.innerWidth}}x${{window.innerHeight}}</p>`;
            document.body.appendChild(urlInfo);
        }});
    </script>
</body>
</html>";

                var buffer = Encoding.UTF8.GetBytes(debugHtml);
                
                response.StatusCode = 200;
                response.ContentType = "text/html; charset=utf-8";
                response.ContentLength64 = buffer.Length;
                response.Headers.Add("Cache-Control", "no-cache");
                
                response.OutputStream.Write(buffer, 0, buffer.Length);
                response.OutputStream.Flush();
            }
            catch (Exception ex)
            {
                StatusChanged?.Invoke($"Error serving debug page: {ex.Message}");
                throw;
            }
        }

        private string GenerateMobileHTML()
        {
            return @"<!DOCTYPE html>
<html lang='de'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent'>
    <meta name='apple-mobile-web-app-title' content='Einsatz√ºberwachung'>
    <title>üêï Einsatz√ºberwachung Mobile</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        .container { 
            max-width: 600px; 
            margin: 0 auto; 
            padding: 20px; 
            padding-bottom: 120px; /* Space for FAB */
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .header p {
            opacity: 0.8;
            font-size: 1rem;
        }
        .status {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .team-grid {
            display: grid;
            gap: 15px;
        }
        .team-card {
            background: rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            touch-action: manipulation;
        }
        .team-card:active {
            background: rgba(255,255,255,0.2);
            transform: scale(0.98);
        }
        .team-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .team-name {
            font-weight: bold;
            font-size: 1.1rem;
        }
        .team-info {
            font-size: 0.9rem;
            opacity: 0.8;
            margin: 5px 0;
        }
        .team-types {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 8px 0;
        }
        .type-badge {
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        .team-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        .status-active { background: #4CAF50; }
        .status-ready { background: #FF9800; }
        .team-time {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .warning-indicator {
            text-align: center;
            font-size: 0.9rem;
            margin: 5px 0;
            font-weight: bold;
        }
        .warning-1 { color: #FF9800; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        .warning-2 { color: #f44336; animation: blink 1s infinite; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.5; } }
        .team-notes {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 12px;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .team-notes h4 {
            font-size: 0.8rem;
            margin-bottom: 8px;
            opacity: 0.8;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .notes-list {
            font-size: 0.75rem;
            line-height: 1.4;
        }
        .note-entry {
            margin-bottom: 4px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .note-time {
            opacity: 0.6;
            font-weight: bold;
        }
        .note-content {
            margin-left: 8px;
        }
        .connection-status {
            position: fixed;
            top: env(safe-area-inset-top, 10px);
            right: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            background: #4CAF50;
            z-index: 1000;
        }
        .quick-actions {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: #2196F3;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s;
            touch-action: manipulation;
        }
        .fab:active { transform: scale(0.9); }
        .no-teams {
            text-align: center;
            padding: 40px 20px;
            opacity: 0.7;
        }
        .readonly-info {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        .mission-details {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .mission-details h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .mission-detail-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9rem;
        }
        
        /* iOS Safari specific fixes */
        @supports (-webkit-appearance: none) {
            .container {
                padding-top: env(safe-area-inset-top, 20px);
            }
        }
        
        /* Loading animation */
        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 3px solid white;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class='connection-status' id='connectionStatus'>üîÑ Verbinde...</div>
    
    <div class='container'>
        <div class='header'>
            <h1>üêï‚Äçü¶∫ Einsatz√ºberwachung</h1>
            <p>Mobile √úbersicht v1.6 (Read-Only)</p>
        </div>
        
        <div class='readonly-info'>
            <strong>üì± Mobile Ansicht</strong><br>
            Diese Ansicht dient nur zur Information. Timer-Steuerung erfolgt √ºber die Desktop-Anwendung.
        </div>
        
        <div class='mission-details' id='missionDetails'>
            <h3>üìã Einsatz-Details</h3>
            <div class='mission-detail-row'>
                <span>üìç Einsatzort:</span>
                <span id='missionLocation'>-</span>
            </div>
            <div class='mission-detail-row'>
                <span>üë§ Einsatzleiter:</span>
                <span id='missionLeader'>-</span>
            </div>
            <div class='mission-detail-row'>
                <span>‚è±Ô∏è Einsatzdauer:</span>
                <span id='missionDuration'>-</span>
            </div>
        </div>
        
        <div class='status' id='missionStatus'>
            <h3>üìä Team-Status</h3>
            <div class='mission-detail-row'>
                <span><strong>Aktive Teams:</strong></span>
                <span id='activeTeams'>-</span>
            </div>
            <div class='mission-detail-row'>
                <span><strong>Gesamte Teams:</strong></span>
                <span id='totalTeams'>-</span>
            </div>
            <div class='mission-detail-row'>
                <span><strong>Letzte Aktualisierung:</strong></span>
                <span id='lastUpdate'>Jetzt</span>
            </div>
        </div>
        
        <div class='team-grid' id='teamGrid'>
            <div class='no-teams'>
                <div class='loading-spinner'></div>
                <h3>üîÑ Lade Teams...</h3>
                <p>Verbindung zum Desktop wird hergestellt...</p>
            </div>
        </div>
    </div>
    
    <div class='quick-actions'>
        <button class='fab' onclick='refreshData()' title='Aktualisieren'>üîÑ</button>
    </div>

    <script>
        let teams = [];
        let missionInfo = {};
        let isOnline = false;
        
        function loadData() {
            // Load mission status
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    missionInfo = data.mission || {};
                    updateMissionDetails(data);
                    updateMissionStatus(data);
                    isOnline = true;
                    updateConnectionStatus();
                })
                .catch(error => {
                    console.error('Error loading status:', error);
                    isOnline = false;
                    updateConnectionStatus();
                });
            
            // Load teams
            fetch('/api/teams')
                .then(response => response.json())
                .then(data => {
                    teams = data;
                    renderTeams();
                    updateStatus();
                    isOnline = true;
                    updateConnectionStatus();
                })
                .catch(error => {
                    console.error('Error loading teams:', error);
                    isOnline = false;
                    updateConnectionStatus();
                    showNoTeamsMessage('Verbindungsfehler - Pr√ºfen Sie die WLAN-Verbindung');
                });
        }
        
        function updateConnectionStatus() {
            const statusEl = document.getElementById('connectionStatus');
            if (isOnline) {
                statusEl.innerHTML = 'üü¢ Verbunden';
                statusEl.style.background = '#4CAF50';
            } else {
                statusEl.innerHTML = 'üî¥ Offline';
                statusEl.style.background = '#f44336';
            }
        }
        
        function updateMissionDetails(data) {
            if (data.mission) {
                document.getElementById('missionLocation').textContent = data.mission.location || 'Unbekannt';
                document.getElementById('missionLeader').textContent = data.mission.leader || 'Unbekannt';
                document.getElementById('missionDuration').textContent = data.mission.duration || '00:00:00';
            }
        }
        
        function updateMissionStatus(data) {
            if (data.mission) {
                document.getElementById('missionDuration').textContent = data.mission.duration || '00:00:00';
            }
        }
        
        function renderTeams() {
            const grid = document.getElementById('teamGrid');
            
            if (teams.length === 0) {
                showNoTeamsMessage('Keine Teams erstellt - Teams werden im Desktop hinzugef√ºgt');
                return;
            }
            
            grid.innerHTML = teams.map(team => generateTeamCard(team)).join('');
        }
        
        function showNoTeamsMessage(message) {
            const grid = document.getElementById('teamGrid');
            grid.innerHTML = `<div class='no-teams'><h3>üìã ${message}</h3><p>Verwenden Sie die Desktop-Anwendung um Teams zu verwalten.</p></div>`;
        }
        
        function generateTeamCard(team) {
            const warningClass = team.isSecondWarning ? 'warning-2' : (team.isFirstWarning ? 'warning-1' : '');
            const warningText = team.isSecondWarning ? 'üö® Zweite Warnung erreicht!' : (team.isFirstWarning ? '‚ö†Ô∏è Erste Warnung erreicht' : '');
            
            // Generate notes HTML if available
            const notesHtml = generateNotesHtml(team);
            
            return `<div class='team-card' onclick='teamCardTap(${team.id})'>
                    <div class='team-header'>
                        <div>
                            <div class='team-name'>${team.name}</div>
                            <div class='team-info'>üêï ${team.dogName || 'Unbekannt'}</div>
                            <div class='team-info'>üë§ ${team.handler || 'Unbekannt'}</div>
                            ${team.helper ? `<div class='team-info'>ü§ù ${team.helper}</div>` : ''}
                        </div>
                        <div class='team-status status-${team.status}'>
                            ${team.status === 'active' ? 'üü¢ Aktiv' : 'üü° Bereit'}
                        </div>
                    </div>
                    <div class='team-types'>
                        ${(team.types || [team.type || 'Unbekannt']).map(type => `<span class='type-badge'>${type}</span>`).join('')}
                    </div>
                    <div class='team-time ${warningClass}'>${team.time}</div>
                    ${warningText ? `<div class='warning-indicator ${warningClass}'>${warningText}</div>` : ''}
                    ${notesHtml}
                </div>`;
        }
        
        function generateNotesHtml(team) {
            if (!team.notes || team.notes.length === 0) {
                return `<div class='team-notes'>
                        <h4>üìù Notizen</h4>
                        <div class='notes-list'>
                            <div class='note-entry'>
                                <span class='note-content' style='opacity: 0.6; font-style: italic;'>Keine Notizen vorhanden</span>
                            </div>
                        </div>
                    </div>`;
            }
            
            const notesHtml = team.notes.map(note => 
                `<div class='note-entry'>
                    <span class='note-time'>${note.time}</span>
                    <span class='note-content'>${note.content}</span>
                </div>`
            ).join('');
            
            return `<div class='team-notes'>
                    <h4>üìù Notizen <small>(${team.notesCount || team.notes.length})</small></h4>
                    <div class='notes-list'>
                        ${notesHtml}
                    </div>
                </div>`;
        }
        
        function updateStatus() {
            const activeCount = teams.filter(t => t.status === 'active').length;
            const totalCount = teams.length;
            
            document.getElementById('activeTeams').textContent = activeCount;
            document.getElementById('totalTeams').textContent = totalCount;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }
        
        function teamCardTap(teamId) {
            // Haptic feedback f√ºr iOS
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            const team = teams.find(t => t.id === teamId);
            if (team) {
                // Kurze visuelle Best√§tigung
                const cards = document.querySelectorAll('.team-card');
                cards[teams.indexOf(team)]?.classList.add('active');
                setTimeout(() => {
                    cards[teams.indexOf(team)]?.classList.remove('active');
                }, 200);
            }
        }
        
        function refreshData() {
            const refreshBtn = document.querySelector('.fab');
            refreshBtn.style.transform = 'rotate(360deg)';
            setTimeout(() => {
                refreshBtn.style.transform = '';
            }, 500);
            
            loadData();
        }
        
        // Auto-refresh every 10 seconds
        setInterval(loadData, 10000);
        
        // Initial load with delay to show loading animation
        setTimeout(loadData, 500);
        
        // App-like behavior
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                setTimeout(loadData, 500);
            }
        });
        
        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            var now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Service Worker registration for offline capability (future enhancement)
        if ('serviceWorker' in navigator) {
            console.log('Service Worker support detected');
        }
    </script>
</body>
</html>";
        }
    }
}
